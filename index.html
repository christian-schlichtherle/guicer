<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <link href="./css/prettify.css" type="text/css" rel="stylesheet"/>
    <script src="./js/prettify.js" type="text/javascript"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>Guicer -   The Guicer DSL</title>
    <style type="text/css" media="all">
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print"/>
    <meta name="Date-Revision-yyyymmdd" content="20130620"/>
    <meta http-equiv="Content-Language" content="en"/>
                    
  </head>
  <body class="composite" onload="prettyPrint()">
    <div id="banner">
                    <div id="bannerLeft">
                Guicer
                </div>
                            <div class="clear"><hr/></div>
    </div>
    <div id="breadcrumbs">
            
                                  <div class="xleft">
        <span id="projectVersion">Version: 0.2-SNAPSHOT</span>
                  |                         <a href="index.html" title="Guicer">Guicer</a>
      &raquo;
          The Guicer DSL
              </div>
            <div class="xright">        
                        </div>
      <div class="clear"><hr/></div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
              
                                                   <h5>Documentation</h5>
                  <ul>
                  <li class="none">
            <strong>The Guicer DSL</strong>
          </li>
          </ul>
                       <h5>Reports</h5>
                  <ul>
                                                                                                                                                                                                                                                                                                                        <li class="expanded">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                    <ul>
                      <li class="none">
            <strong>About</strong>
          </li>
                      <li class="none">
                          <a href="plugin-management.html" title="Plugin Management">Plugin Management</a>
            </li>
                      <li class="none">
                          <a href="distribution-management.html" title="Distribution Management">Distribution Management</a>
            </li>
                      <li class="none">
                          <a href="dependency-info.html" title="Dependency Information">Dependency Information</a>
            </li>
                      <li class="none">
                          <a href="source-repository.html" title="Source Repository">Source Repository</a>
            </li>
                      <li class="none">
                          <a href="mail-lists.html" title="Mailing Lists">Mailing Lists</a>
            </li>
                      <li class="none">
                          <a href="issue-tracking.html" title="Issue Tracking">Issue Tracking</a>
            </li>
                      <li class="none">
                          <a href="integration.html" title="Continuous Integration">Continuous Integration</a>
            </li>
                      <li class="none">
                          <a href="plugins.html" title="Project Plugins">Project Plugins</a>
            </li>
                      <li class="none">
                          <a href="license.html" title="Project License">Project License</a>
            </li>
                      <li class="none">
                          <a href="dependency-management.html" title="Dependency Management">Dependency Management</a>
            </li>
                      <li class="none">
                          <a href="team-list.html" title="Project Team">Project Team</a>
            </li>
                      <li class="none">
                          <a href="project-summary.html" title="Project Summary">Project Summary</a>
            </li>
                      <li class="none">
                          <a href="dependencies.html" title="Dependencies">Dependencies</a>
            </li>
              </ul>
        </li>
          </ul>
                                              
                              </div>
    </div>
    <div id="bodyColumn" class="content">
      <div id="contentBox">
                                      <p></p>
<div class="section">
<h2>The Guicer DSL<a name="The_Guicer_DSL"></a></h2>
<div class="section">
<h3>Abstract<a name="Abstract"></a></h3>
<p>Guicer is an alternative Domain Specific Language (DSL) for configuring Guice injectors which is simpler and more concise than the original Guice DSL. This article provides a brief introduction to the Guicer DSL.</p></div>
<div class="section">
<h3>Overview<a name="Overview"></a></h3>
<p>The Guicer DSL uses simple method chaining for configuring a Guice <a class="externalLink" href="http://google-guice.googlecode.com/svn/tags/3.0/javadoc/com/google/inject/Injector.html"><tt>Injector</tt></a> with modules and bindings. It does not require you to implement or subclass anything (e.g. a Module).</p>
<p>The Guicer DSL supports&#x2026;</p>

<ul>
  
<li>sub-smodules,</li>
  
<li>private-modules,</li>
  
<li>annotated bindings,</li>
  
<li>bindings for classes,</li>
  
<li>bindings for type literals,</li>
  
<li>bindings for constants and</li>
  
<li>scoped bindings.</li>
</ul>
<p>The Guicer DSL doesn&#x2019;t yet support&#x2026;</p>

<ul>
  
<li><tt>@Provides</tt> methods.</li>
</ul>
<p>For everything which isn&#x2019;t supported yet, you can add custom modules to the Guice injector via the Guicer DSL, so that you can exploit Guice to the fullest.</p>

<blockquote>
<p>If you like to add support for a specific feature to the Guicer DSL, I welcome pull requests. Please note that to be acceptable, the changes/extensions in the pull request need to maintain the general concept of method chaining because this is what sets the Guicer DSL apart from the original Guice DSL.</p>
</blockquote></div>
<div class="section">
<h3>Prerequisites<a name="Prerequisites"></a></h3>
<p>You need Java SE 6 and Maven 3.0.4 or higher to use this project. Furthermore, you need to checkout the <a class="externalLink" href="http://github.com/christian-schlichtherle/guicer">source code repository</a> and build the project yourself because the artifacts are not yet available on Maven Central.</p></div>
<div class="section">
<h3>Your First Configuration<a name="Your_First_Configuration"></a></h3>
<p>The following class creates a minimally configured Guice injector with the Guicer DSL:</p>

<div class="source">
<pre>package de.schlichtherle.demo.guice;

import com.google.inject.Injector;
import de.schlichtherle.demo.guice.guicer.GuiceContext;

public class Bootstrap {

    private final Injector injector = new GuiceContext()
            .injector()
                .build();

    ...
}
</pre></div>
<p>With the Guicer DSL, you start by creating a new <tt>GuiceContext</tt>. In fact, this is the only <tt>import</tt> and the only <tt>new</tt> statement you need with the Guicer DSL. Everything else gets configured via method chaining / drilling down from the <tt>GuiceContex</tt>.</p>
<p>After creating the <tt>GuiceContext</tt>, you need to call <tt>injector()</tt> in order to create a builder for a Guice <tt>Injector</tt>. When you are done with using the builder, you need to call <tt>build()</tt> in order to obtain the configured <tt>Injector</tt>.</p></div>
<div class="section">
<h3>Adding Modules<a name="Adding_Modules"></a></h3>
<p>In the previous example, the configuration is empty and so you couldn&#x2019;t use the configured injector to do many useful things. Let&#x2019;s start adding a module to the injector:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .inject()
            .build();
</pre></div>
<p>The call to <tt>module()</tt> creates an injection for a Guice <tt>Module</tt>. When you are done with using the injection, you need to call <tt>inject()</tt> in order to make it inject the configured <tt>Module</tt> into the builder for the <tt>Injector</tt>.</p>
<div class="section">
<h4>Adding Sub-Modules<a name="Adding_Sub-Modules"></a></h4>
<p>This is a recursive pattern, so you can add modules to modules like this:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .module()
                    .inject()
                .inject()
            .build();
</pre></div>
<p>Think of the call to <tt>inject()</tt> as a closing brace which returns control to the parent scope. If you know XML, this should be familiar to you. In XML, the preceeding code could have been expressed like this:</p>

<div class="source">
<pre>&lt;injector&gt;
    &lt;module&gt;
        &lt;module&gt;
        &lt;/module&gt;
    &lt;/module&gt;
&lt;/injector&gt;
</pre></div>
<p>As you can see, <tt>inject()</tt> and <tt>build()</tt> in the Guicer DSL are the equivalent to <tt>&lt;/module&gt;</tt> and <tt>&lt;/injector&gt;</tt> in XML. I prefer to have <tt>inject()</tt> and <tt>build()</tt> indented one level more, however. Of course, this is a matter of style and you might as well write this:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .module()
                .inject()
            .inject()
        .build();
</pre></div></div>
<div class="section">
<h4>Adding Existing Modules<a name="Adding_Existing_Modules"></a></h4>
<p>Instead of configuring a module in the Guicer DSL, you can also tell it to use an existing module:</p>

<div class="source">
<pre>Module myModule = ...
Injector injector = new GuiceContext()
        .injector()
            .module(myModule)
            .build();
</pre></div>
<p>This vehicle should be used whenever you want to use a Guice feature which is not yet supported in the Guicer DSL.</p></div>
<div class="section">
<h4>Building Modules<a name="Building_Modules"></a></h4>
<p>You can use the Guicer DSL to build modules for use with the original Guice DSL, too:</p>

<div class="source">
<pre>Module module = new GuiceContext()
        .injector()
            .module()
                .build();
</pre></div>
<p>Note that the <tt>module()</tt> declaration ends with <tt>build()</tt> instruction instead of the usual <tt>inject()</tt>. This instructs the module builder to build and return the module.</p></div></div>
<div class="section">
<h3>Configuring Modules<a name="Configuring_Modules"></a></h3>
<p>So far, the module configurations built with the Guicer DSL were empty, so the configured <tt>Injector</tt> won&#x2019;t do many useful things. Let&#x2019;s start adding a binding for a class to the module configuration:</p>

<blockquote>
<p>The following code samples depend on the Guice Demo project on GitHub. Please check out the branch <tt>guicer</tt> of its <a class="externalLink" href="http://github.com/christian-schlichtherle/guice-demo">source code repository</a> if you need a working sample.</p>
</blockquote>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .bind(Printer.class)
                    .to(TeePrinter.class)
                    .inject()
                .inject()
            .build();
</pre></div>
<p>This binds the <tt>Printer</tt> interface to the <tt>TeePrinter</tt> implementation class.</p>
<div class="section">
<h4>Configuring Private Modules<a name="Configuring_Private_Modules"></a></h4>
<p>A <tt>TeePrinter</tt> needs a primary and secondary <tt>Printer</tt> injected. In Guice, you need to configure two instances of the <tt>PrivateModule</tt> class in order to do this. With the Guicer DSL, this is straightforward:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .bind(Printer.class)
                    .to(TeePrinter.class)
                    .inject()
                .module()
                    .exposeAndBind(Printer.class)
                        .annotatedWith(named(&quot;primary&quot;))
                        .to(BanneredPrinter.class)
                        .inject()
                    ...
                    .inject()
                .module()
                    .exposeAndBind(Printer.class)
                        .annotatedWith(named(&quot;secondary&quot;))
                        .to(BanneredPrinter.class)
                        .inject()
                     ...
                    .inject()
                .inject()
            ...
            .build();
</pre></div>
<p>By calling <tt>exposeAndBind(Printer.class)</tt> I tell the module builder to build a <tt>PrivateModule</tt> instead of an <tt>AbstractModule</tt>. The private module will have the specified binding and expose its type.</p>
<p>Calling <tt>exposeAndBind(Class&lt;?&gt;)</tt> is a shorthand expression for:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                .bind(Printer.class)
                    .to(TeePrinter.class)
                    .inject()
                .module()
                    .expose(Printer.class)
                        .annotatedWith(named(&quot;primary&quot;))
                        .inject()
                    .bind(Printer.class)
                        .annotatedWith(named(&quot;primary&quot;))
                        .to(BanneredPrinter.class)
                        .inject()
                    ...
                    .inject()
                .module()
                    .expose(Printer.class)
                        .annotatedWith(named(&quot;secondary&quot;))
                        .inject()
                    .bind(Printer.class)
                        .annotatedWith(named(&quot;secondary&quot;))
                        .to(BanneredPrinter.class)
                        .inject()
                     ...
                    .inject()
                .inject()
            ...
            .build();
</pre></div>
<p>This feature not only saves some lines of code, it also eliminates a point of failure because the generated exposing and binding will always match.</p></div>
<div class="section">
<h4>Qualifying Bindings With Annotations<a name="Qualifying_Bindings_With_Annotations"></a></h4>
<p>In the previous example, I&#x2019;ve also added calls to <tt>annotatedWith(named(...))</tt> in order to disambiguate between the primary and secondary printer for the <tt>TeePrinter</tt>. The <tt>named(String)</tt> function is a static import from <tt>com.google.inject.name.Names</tt> which creates an annotation which is comparable to the annotation type <tt>javax.inject.Named</tt>. With the given parameters, I specifically ask for an injection point of the type <tt>Printer</tt> which is respectively annotated with <tt>@Named(&quot;primary&quot;)</tt> or <tt>@Named(&quot;secondary&quot;)</tt>.</p></div>
<div class="section">
<h4>Binding Constants<a name="Binding_Constants"></a></h4>
<p>The secondary printer in the previous example needs a boolean parameter further down its decorator chain. You can use the same syntax as with the original Guice DSL to configure this. Here&#x2019;s the complete configuration for the secondary printer, including the constant binding:</p>

<div class="source">
<pre>Injector injector = new GuiceContext()
        .injector()
            .module()
                ...
                .module()
                    .exposeAndBind(Printer.class)
                        .annotatedWith(named(&quot;secondary&quot;))
                        .to(BanneredPrinter.class)
                        .inject()
                    .bind(Printer.class)
                        .annotatedWith(context(BanneredPrinter.class))
                        .to(CheckedPrinter.class)
                        .inject()
                    .bind(Printer.class)
                        .annotatedWith(context(CheckedPrinter.class))
                        .to(FilePrinter.class)
                        .inject()
                    .bind(File.class)
                        .annotatedWith(context(FilePrinter.class))
                        .toInstance(new File(&quot;print.log&quot;))
                        .inject()
                    .bindConstant()
                        .annotatedWith(named(&quot;append&quot;))
                        .to(true)
                        .inject()
                    .inject()
                .inject()
            .build();
</pre></div>
<p>The sub-module exposes a binding for <tt>Printer</tt> to a <tt>BanneredPrinter</tt> with a <tt>CheckedPrinter</tt> and a <tt>FilePrinter</tt> as their respective delegates. The <tt>FilePrinter</tt> will append its output to the file named <tt>print.log</tt> in the current directory.</p></div></div></div>
              </div>
    </div>
    <div class="clear"><hr/></div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2013
                        <a href="http://schlichtherle.de">Schlichtherle IT Services</a>.
            All Rights Reserved.      
                                   <span id="publishDate">Last Published: 2013-06-20</span>
                        </div>
      <div class="clear"><hr/></div>
    </div>
  </body>
</html>
